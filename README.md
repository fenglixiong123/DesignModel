# 24种设计模式

* [适配器模式](#适配器模式adapter)
* [责任链模式](#责任链模式chain)
* [装饰者模式](#装饰者模式decorate)
* [观察者模式](#观察者模式observer)
* [单例模式](#单例模式singleton)
* [模板模式](#模板模式template)
* [策略模式](#策略模式strategy)

## 适配器模式：adapter

### 场景：

去过香港迪拜等的同学都知道，那边用的插座跟我们不一样，三插头，而我们的是二插头，这时候就需要
用一个转换器将三插头电转换成二插头的

### 定义：

将一个类的接口转成客户期望的另外一个接口。适配器模式使得原本由于接口不匹配而不能一起工作的那些类可以一起工作。

## 责任链模式：chain

### 定义：

为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。

## 装饰者模式：decorate

对已有的业务逻辑进一步的封装，使其增加额外的功能

## 观察者模式：observer

### 场景：
* 比如在学校上自习的时候，大家肯定都有过交头接耳、各种玩耍的经历，这时总会有一个“放风”的小伙伴，当老师即将出现时及时“通知”大家老师来了。
* 比如在一个目录下建立一个文件，这时系统会通知目录管理器增加目录，并通知磁盘减少空间，在这里，文件就是观察者，目录管理器和磁盘就是被观察者。

### 定义：
又叫发布-订阅模式（Publish/Subscribe），定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。

### 重点  

一个对象状态改变，所有的依赖对象都将得到通知  
当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象有待改变的时候，应该考虑使用观察者模式。

而使用观察者模式的动机在于：将一个系统分割成一系列相互协作的类有一个很不好的副作用，就是需要维护相关对象间的一致性，我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便，而观察者模式所做的工作就是在解除耦合。

## 单例模式：singleton
保证构造方法私有，不允许外部私自创建
### 定义：
这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。
### 类型：
* 饿汉模式(线程安全)
    * 优点：没有加锁，执行效率会提高。
    * 缺点：类加载时就初始化，浪费内存。
* 懒汉模式(非线程安全)
    * 优点：第一次调用才初始化，避免内存浪费。
    * 缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。
  
  解决线程安全：  
  1.方法加锁  synchronized，但是效率低  
  2.双重检查  锁加在第一层检查里面，则后面线程就不需要锁  
  3.holder方式（优雅方式，利用的静态加载的特性）  
  4.枚举方式


## 模板模式：template
### 场景：
就比如说做饭，同样的步骤不同的人做味道是不一样的。或者是造汽车，同样的步骤，造车厂商不一样，造template
出来的汽车质量不同。
### 定义：
它定义一个操作中的算法的框架，而将一些步骤延迟到了子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些步骤。
案例：<br>
比如就做个西红柿鸡蛋吧。我们可以简单地定义一下步骤：

* 第一步：放油
* 第二步：放西红柿
* 第三步：放鸡蛋

a. 模板方法：他定义了一系列方法，提供了一个骨架。<br>
b.具体类：实现上面模板方法类提供的骨架。不同的具体类实现这个模板方法的骨架方式是不一样的。

## 策略模式：strategy

### 定义：
策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。
需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类

策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。
因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。








