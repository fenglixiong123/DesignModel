# 24种设计模式

* [单例模式](#单例模式singleton)
* [模板模式](#模板模式template)
* [策略模式](#策略模式strategy)

## 单例模式：singleton
保证构造方法私有，不允许外部私自创建
### 定义：
这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。
### 模式：
* 饿汉模式(线程安全)
    * 优点：没有加锁，执行效率会提高。
    * 缺点：类加载时就初始化，浪费内存。
* 懒汉模式(非线程安全)
    * 优点：第一次调用才初始化，避免内存浪费。
    * 缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。
  
  解决线程安全：  
  1.方法加锁  synchronized，但是效率低  
  2.双重检查  锁加在第一层检查里面，则后面线程就不需要锁  
  3.holder方式（优雅方式，利用的静态加载的特性）  
  4.枚举方式
  
## 模板模式：template
### 场景：
就比如说做饭，同样的步骤不同的人做味道是不一样的。或者是造汽车，同样的步骤，造车厂商不一样，造template
出来的汽车质量不同。
### 定义：
它定义一个操作中的算法的框架，而将一些步骤延迟到了子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些步骤。
案例：<br>
比如就做个西红柿鸡蛋吧。我们可以简单地定义一下步骤：

* 第一步：放油
* 第二步：放西红柿
* 第三步：放鸡蛋

a. 模板方法：他定义了一系列方法，提供了一个骨架。<br>
b.具体类：实现上面模板方法类提供的骨架。不同的具体类实现这个模板方法的骨架方式是不一样的。

## 策略模式：strategy

### 定义：
策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。
需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类

策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。
因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。








